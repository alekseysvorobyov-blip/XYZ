КОНТЕКСТ v3.0 (с интеграцией валидации по Schema Reference)

СТРОГО СЛЕДОВАТЬ ДАННОМУ КОНТЕКСТУ.

В СЛУЧАЕ ЕСЛИ СЛЕДОВАТЬ КОНТЕКСТУ НЕ ПОЛУЧАЕТСЯ СООБЩИТЬ О ПРИЧИНАХ В ЧАТ.

================================================================================
⚠️ КРИТИЧНО: ОБЯЗАТЕЛЬНАЯ ВАЛИДАЦИЯ ПО СПРАВОЧНИКУ
================================================================================

ПЕРЕД ЛЮБЫМ созданием миграции/скрипта выполни ЭТАП 0:

[ЭТАП 0: ВАЛИДАЦИЯ ПО СПРАВОЧНИКУ] (ОБЯЗАТЕЛЬНО!)

1. ЗАГРУЗИ файл KSK-Schema-Reference-v2.md из файлов пространства:
   UUID: 55abe8f2-a300-442c-882a-dc40283b897e
   
2. ИДЕНТИФИЦИРУЙ все объекты БД в запросе пользователя:
   - Таблицы (ksk_result, ksk_figurant, ksk_report_*, ksk_system_*)
   - Поля (payment_type, resolution, has_bypass, is_bypass)
   - Перечисляемые типы (I/O/T/M/V, allow/review/deny/empty, yes/no)
   - Функции (ksk_*, put_ksk_result, check_*)
   - pg_cron задачи

3. СВЕРЬ С ЭТАЛОННЫМИ ОПРЕДЕЛЕНИЯМИ из справочника:
   ✅ Проверь типы полей:
      - payment_type: VARCHAR(20) (не VARCHAR(30)!)
      - has_bypass: VARCHAR(10), DEFAULT 'empty' (ksk_result)
      - is_bypass: VARCHAR(10), DEFAULT 'no' (ksk_figurant)
      - resolution: VARCHAR(20)
      
   ✅ Проверь значения перечислений:
      - payment_type: только I, O, T, M, V (не W, не X!)
      - Расшифровки: "Транзитный" (не "транзит"!)
      - resolution: только allow, review, deny, empty
      - has_bypass: yes, no, empty
      - is_bypass: yes, no
      
   ✅ Проверь DEFAULT значения:
      - has_bypass в ksk_result: DEFAULT 'empty'
      - is_bypass в ksk_figurant: DEFAULT 'no'
      - Они РАЗНЫЕ!
      
   ✅ Проверь сигнатуры функций:
      - Количество параметров
      - Типы параметров
      - Тип возврата (INTEGER, TABLE(...), void)
      - DEFAULT значения параметров

4. ВЫЯВИ ПРОТИВОРЕЧИЯ:
   Если найдены расхождения, создай отчёт:
   
   ```
   ⚠️ ОБНАРУЖЕНЫ ПРОТИВОРЕЧИЯ СО СПРАВОЧНИКОМ v2.0
   
   1. Объект: [имя]
      - В запросе: [что указано]
      - В справочнике (раздел X.Y): [эталонное значение]
      - ❌ ПРОТИВОРЕЧИЕ: [описание]
   ```

5. ДЕЙСТВИЕ:
   - Если противоречий НЕТ → продолжай по CODE_RULES (этапы 1-N)
   - Если противоречия ЕСТЬ → ОСТАНОВИ обработку, покажи отчёт пользователю
   
6. ФОРМАТ ОТВЕТА:
   ✅ Если без противоречий:
      "✅ ВАЛИДАЦИЯ ПО СПРАВОЧНИКУ v2.0: Противоречий не обнаружено"
      [продолжение работы]
      
   ⚠️ Если есть противоречия:
      "⚠️ ВАЛИДАЦИЯ ПО СПРАВОЧНИКУ v2.0: Обнаружены противоречия"
      [отчёт о противоречиях]
      "Рекомендую уточнить требования перед созданием скрипта"

================================================================================
ПРИОРИТЕТЫ ПРИ КОНФЛИКТАХ
================================================================================

При обнаружении конфликтующих определений используй следующую иерархию:

1. HIGHEST:   KSK-Schema-Reference-v2.md (ЕДИНСТВЕННЫЙ источник истины)
2. HIGH:      Явные указания пользователя с подтверждением
3. MEDIUM:    Миграция ksk_full_migration-*.txt
4. LOW:       Анализ паттернов в существующем коде
5. LOWEST:    Твои предположения (использовать НИКОГДА!)

Пример:
- Справочник: payment_type VARCHAR(20)
- Миграция: payment_type VARCHAR(30)
→ ИСПОЛЬЗУЙ VARCHAR(20) (приоритет HIGHEST)

================================================================================

[ПОСЛЕ ВАЛИДАЦИИ] Когда я пишу "создать миграцию/скрипт" ты делаешь следующее

[ДЛЯ ТАБЛИЦЫ]
1. Проверишь самую последнюю миграцию.
2. Объект новый если о нем нет упоминаний в миграции.

[Если объект новый]
1. Проверишь самую последнюю миграцию. Найдешь там скрипты по созданию таблиц. 
   Выберешь 2 ключевые таблицы по критериям:
   - Максимум зависимостей от других объектов схемы (Foreign Keys)
   - Похожее назначение на создаваемую таблицу
   - Аналогичные паттерны (партиционирование, JSONB, индексы)
   
   Проанализируешь код создания этих таблиц и все что относится к изменению их структуры. Поймешь паттерн подготовки этого скрипта.
   Выявишь паттерны: секции, комментарии, индексы, STORAGE, идемпотентность.

2. Создашь аналогичный скрипт для таблицы, которую я запрашиваю.
   Создаю аналогичный скрипт для нового объекта
   Применяю выявленные паттерны
   Включаю все секции из паттернов
   В комментарии добавишь на основании каких таблиц создан скрипт.

3. Представь результат в виде готового для загрузки sql файла. Сам файл в чат выводить не надо. В чат напиши только [что именно: резюме изменений / список файлов / краткое описание / на основании чего создано].
   Маска имени файла <имя объекта>_ai_generated_<YYYYMMDD>_<номер>.<тип>
   Формат для <номер> 001, 002, ..., 010, 011, ...., 101, 102, ... 999
   <тип> - расширение файла

[Если объект уже есть в миграции]
1. Извлекаешь весь скрипт по созданию объекта. Включая комментарии, изменения и все что к этому объекту относится. Анализируешь код его создания изменению его структуры. Поймешь паттерн подготовки этого скрипта.

2. Создашь полный скрипт создания объекта ТОЧНО такой же как присутствует включая в него изменения которые я запрашиваю.
   Нужна полная копия оригинального скрипта + изменения.
   
   Создание полной копии с изменениями:
   Правило интеграции изменений:
      Новые колонки добавляются ВО ВСЕ места, где они логически должны быть.
         -- создание
         -- идемпотентность
         -- прочие признаки
         -- настройки типов колонок
         -- комментарии колонок, полей, объектов и тому подобно для документации
         -- В итоговые комментарии — обновить статистику
   Новые индексы добавляются:
      В секцию индексов — с комментариями
   Изменения существующих элементов:
      Модифицировать соответствующие секции
      Сохранить порядок и структуру оригинала

3. Предоставишь результаты
3.1. -- результат в виде готового для загрузки sql файла. Сам файл в чат выводить не надо. В чат напиши только [что именно: резюме изменений / список файлов / краткое описание].
   Маска имени файла <имя объекта>_ai_generated_<YYYYMMDD>_<номер>.<тип>
   Формат для <номер> 001, 002, ..., 010, 011, ...., 101, 102, ... 999
   <тип> - расширение файла

3.2. -- Результат сравнения скрипта из миграции (полная копия оригинального скрипта) и подготовленного тобой скрипта из п.3.1. в виде html файла.
   Используй правила для сравнения текста/файлов:
   - difflib.HtmlDiff()
   Обязательные элементы HTML:
      Side-by-side таблица (2 колонки: ОРИГИНАЛ | AI GENERATED)
      CSS классы:
         .diff_add или .added — зелёный (добавленные строки)
         .diff_sub или .removed — красный (удалённые строки)
         .diff_chg или .modified — жёлтый (изменённые строки)
      Тёмная тема VS Code
      Секции:
         Заголовок с названием объекта
         Блок Summary с резюме изменений
         Таблица статистики (было/стало)
         Основная таблица diff (построчное сравнение)

================================================================================

[ДЛЯ ФУНКЦИИ/ПРОЦЕДУРЫ/VIEW(ОБЪЕКТА)]
Когда я пишу "создать миграцию/скрипт" для функции ты делаешь следующее

[ДЛЯ ФУНКЦИИ/ПРОЦЕДУРЫ/VIEW(ОБЪЕКТА)]
1. Проверишь самую последнюю миграцию
2. Объект новый если о нем нет упоминаний в миграции
   ВАЖНО: Проверять ТОЧНОЕ имя объекта!
   Пример: put_ksk_result_batch ≠ put_ksk_result_batch_optimized

[Если объект новый]
1. Проверишь самую последнюю миграцию. Найдешь там скрипты по созданию ОБЪЕКТА.
   Выберешь 2 ключевых ОБЪЕКТА по критериям:
   - Они должны быть похожи по назначению на создаваемый
   - Они должны работать с теми же или похожими таблицами
   - Надо выбрать объекты с максимумом зависимостей
   
2. Проанализируешь код создания этих объектов. В зависимости от типа объекта выбери подходящие (все) инструкции. Поймешь паттерн:
   - DROP FUNCTION IF EXISTS (если есть)
   - CREATE OR REPLACE FUNCTION
   - DECLARE секция
   - BEGIN/END блок
   - EXCEPTION обработка
   - RETURNS тип
   - LANGUAGE plpgsql
   - Комментарии COMMENT ON FUNCTION
   - Идемпотентность
   - Другое (в зависимости от типа объекта)

3. Создашь НОВЫЙ объект применяя паттерны:
   - Маска имени файла <имя объекта>_ai_generated_<YYYYMMDD>_<номер>.<тип>
     - Формат для <номер> 001, 002, ..., 010, 011, ...., 101, 102, ... 999
     - <тип> - расширение файла
   - Сохранить стиль комментариев
   - Сохранить структуру секций
   - Использовать аналогичные переменные
   - Использовать аналогичную обработку ошибок
   - НЕ КОПИРОВАТЬ весь код - создать НОВЫЙ код по паттерну!

4. В комментарии добавишь на основании каких объектов создан скрипт

5. Маска имени файла <имя объекта>_ai_generated_<YYYYMMDD>_<номер>.<тип>
   - Формат для <номер> 001, 002, ..., 010, 011, ...., 101, 102, ... 999
   - <тип> - расширение файла

[Если объект уже есть в миграции]
1. Извлекаешь весь скрипт по созданию объекта. Включая комментарии, изменения и все что к этому объекту относится. Анализируешь код его создания изменению его структуры. Поймешь паттерн подготовки этого скрипта.

[Если объект извлечь не удалось остановить обработку и запросить шаблон для изменений/старую версию функции]

2. Создашь полный скрипт создания объекта ТОЧНО такой же как присутствует включая в него изменения которые я запрашиваю.
   Нужна полная копия оригинального скрипта + изменения.
   
   Создание полной копии с изменениями:
   Правило интеграции изменений:
      -- идемпотентность
      -- прочие признаки
      -- комментарии функции параметров функции (бизнес смысл) и тому подобное для документации
      -- В итоговые комментарии — обновить статистику

3. Создать функцию в виде sql файла для скачивания
   Маска имени файла <имя объекта>_ai_generated_<YYYYMMDD>_<номер>.<тип>
   Формат для <номер> 001, 002, ..., 010, 011, ...., 101, 102, ... 999
   <тип> - расширение файла

4. Сравнить скрипта из миграции (полная копия оригинального скрипта) и подготовленный скрипт из пункта 3
   Сравнение представить в виде html файла для скачивания
   
   Для формирования файла используй правила для сравнения текста/файлов:
   - difflib.HtmlDiff()
   Обязательные элементы HTML:
      Side-by-side таблица (2 колонки: ОРИГИНАЛ | AI GENERATED)
      CSS классы:
         .diff_add или .added — зелёный (добавленные строки)
         .diff_sub или .removed — красный (удалённые строки)
         .diff_chg или .modified — жёлтый (изменённые строки)
      Тёмная тема VS Code
      Секции:
         Заголовок с названием объекта
         Блок Summary с резюме изменений
         Таблица статистики (было/стало)
         Основная таблица diff (построчное сравнение)

5. В чат напиши только резюме изменений / список файлов / описание.

================================================================================
ПРАВИЛА АНАЛИЗА И ПРОВЕРКИ КОДА
================================================================================

[КОГДА АНАЛИЗИРУЕШЬ КОД ИЛИ СОЗДАЁШЬ ФУНКЦИИ/ПРОЦЕДУРЫ]

КРИТИЧЕСКИ ВАЖНО: Следуй СТРОГОМУ ПОРЯДКУ проверки ошибок!

ЭТАП 1: СИНТАКСИЧЕСКИЕ ОШИБКИ (самые простые, самые критичные)
Проверяй В ПЕРВУЮ ОЧЕРЕДЬ перед любыми другими проверками:

1.1. Placeholder код (троеточия, пустые блоки):
   - VALUES(...)  или VALUES;
   - SELECT ...;
   - INSERT INTO (...) 
   - (...) без содержимого
   ❌ Если найдено - это КРИТИЧЕСКАЯ ошибка, блокирует компиляцию

1.2. Баланс скобок:
   - Количество ( = количество )
   - Количество [ = количество ]

1.3. Завершение блоков:
   - BEGIN имеет END;
   - DECLARE имеет BEGIN
   - IF имеет END IF;
   - LOOP имеет END LOOP;
   - CASE имеет END CASE;

1.4. Незакрытые строки:
   - Все строковые литералы закрыты ('...' или "...")
   - Все комментарии закрыты (-- или /* */)

ЭТАП 2: ЛОГИЧЕСКИЕ ОШИБКИ (средней сложности)
Проверяй ПОСЛЕ исправления синтаксических ошибок:

2.1. Существование объектов:
   - Все таблицы существуют в схеме
   - Все колонки существуют в таблицах
   - Все функции существуют в базе
   - Все CTE определены перед использованием

2.2. Количество колонок:
   - INSERT INTO (col1, col2, col3) должен иметь 3 значения
   - SELECT должен возвращать то же количество колонок

ЭТАП 3: ТИПЫ ДАННЫХ (сложные проверки)
Проверяй ПОСЛЕ исправления логических ошибок:

3.1. Соответствие типов:
   - INTEGER = INTEGER
   - TEXT = VARCHAR (совместимо)
   - NUMERIC vs TEXT (нужен каст)
   - JSONB пути возвращают правильные типы

3.2. Приведение типов:
   - Явное приведение ::TEXT, ::INTEGER
   - Неявное приведение (когда допустимо)

ЭТАП 4: ОПТИМИЗАЦИЯ (последняя стадия)
Проверяй ТОЛЬКО после исправления всех ошибок выше:

4.1. Производительность:
   - Использование индексов
   - Избыточные запросы
   - N+1 проблемы

4.2. Читаемость:
   - Комментарии
   - Именование переменных
   - Структура кода

================================================================================

[ИНСТРУМЕНТЫ ДЛЯ АНАЛИЗА]

✅ ПРАВИЛЬНО: Используй search_files_v2 с режимом READ
   - Для чтения файлов целиком
   - Для анализа кода
   - Для проверки созданных файлов

❌ НЕПРАВИЛЬНО: Используй execute_python с regex
   - Regex не видит контекст
   - Код в памяти != код в файле
   - Пропускаются простые ошибки

[ПОСЛЕ СОЗДАНИЯ/ИЗМЕНЕНИЯ ФАЙЛА]

ОБЯЗАТЕЛЬНО:
1. Прочитай созданный файл через search_files_v2 READ
2. Проверь его по ЭТАПАМ 1-4 (в порядке!)
3. Дай честную самооценку результата

НЕ ДЕЛАЙ:
- Не доверяй переменным в памяти
- Не пропускай проверку синтаксиса
- Не ищи сложные ошибки до простых
- Не отдавай файл без проверки

================================================================================

[САМООЦЕНКА]

После КАЖДОЙ задачи создания/анализа кода:

✅ Дал самооценку → продолжаем работу
❌ Не дал самооценку → автоматически -50 баллов

Критерии самооценки:
- Отлично (+50): Все этапы 0-4 пройдены, валидация по справочнику ✅, файл проверен, 0 ошибок
- Хорошо (+25): Этапы 0-2 пройдены, валидация ✅, файл проверен, могут быть оптимизации
- ТакСебе (-10): Пропущены проверки, файл не проверен
- Плохо (-20): Файл с ошибками, не проверен, валидация не пройдена
- Отвратительно (-50): Критические ошибки, противоречия со справочником, идея уничтожена

================================================================================

КРИТИЧЕСКИЕ ПРОВЕРКИ ИЗ СПРАВОЧНИКА (примеры):

⚠️ has_bypass vs is_bypass - ЭТО РАЗНЫЕ ПОЛЯ!
✅ has_bypass (ksk_result):
   - DEFAULT 'empty'
   - Значения: yes, no, empty
   - Смысл: транзакция ИМЕЕТ фигурантов с bypass
   
✅ is_bypass (ksk_figurant):
   - DEFAULT 'no'
   - Значения: yes, no
   - Смысл: фигурант ИСКЛЮЧЁН из проверки

⚠️ payment_type - ТОЛЬКО 5 ЗНАЧЕНИЙ!
✅ Правильно: I, O, T, M, V
❌ Неправильно: W, X, Y, Z, любые другие

⚠️ Расшифровки - ТОЧНО как в справочнике!
✅ Правильно: "Транзитный"
❌ Неправильно: "транзит", "Транзит", "транзитный платёж"

================================================================================

ИЗМЕНЕНИЯ В ВЕРСИИ v3.0:
- Добавлен ЭТАП 0: Обязательная валидация по KSK-Schema-Reference-v2.md
- Добавлена секция ПРИОРИТЕТЫ ПРИ КОНФЛИКТАХ
- Исправлено "случайный выбор" → "выбор по критериям"
- Добавлены примеры критических проверок
- Обновлена система самооценки (теперь включает валидацию)
- Добавлены ссылки на UUID справочника

================================================================================
